# Recherche avec critères sur des attributs de document {#core-ref:0f8f5e66-5ed7-47b8-bcfd-038e0eec9d26}

Dans le cas où une famille d'appartenance est précisée, il est possible
d'utiliser les attributs de cette famille comme critères.

    [php]
    $searchedName='jean';
    $s=new SearchDoc("","MY_CONTACT"); // recherche sur les document de la famille "MY_CONTACT"
    $s->addFilter("my_firstname ~* 'jean'"); // prénom contient jean 
    $s->setObjectReturn(true);
    $s->search();
     
    while ($doc=$s->nextDoc()) {
        print "$k)".$doc->getTitle()."(".$doc>getRawValue("my_mail","nomail").")\n";
    }

L'exemple ci-dessus montre la recherche de toutes les personnes dont le prénom
contient *jean*. Les filtres ajoutés au moyen de la méthode `addFilter`
établissent une conjonction de conditions (opérateur `and`). Pour établir une
disjonction, il faut l'écrire manuellement en SQL en utilisant l'opérateur
logique `or`.

Les [opérateurs sql][pgop] utilisés doivent être compatibles avec les types des
[attributs][docattributs] stockés en base de données.

    [php]
    $s=new SearchDoc("","MY_CONTACT");// famid : toute famille
    $s->addFilter("my_firstname ~* 'jean|patrick'"); // prénom contient jean ou patrick
    // mail fini par .org ou cp commence par 31//
    $s->addFilter("(my_mail ~ '\.org$') or (my_postalcode ~ '^31')");   
    $s->setObjectReturn(true);
    $s->search();
     
    while ($doc=$s->nextDoc()) {
        print "$k)".$doc->title."(".$doc->getRawValue("my_mail","nomail").':'.
            $doc->getRawValue("my_postalcode").")\n";
     }

**Note** : Les types [`docid`][attdocid] sont enregistrés au format `text` dans la
    base de données.


## Recherche sur des attributs de type énumérés (getKindDoc) {#core-ref:f5a2cf74-ee40-4df8-93fa-f75b0b9f5aaf}

Pour rechercher des documents suivant des attributs de type énumérés, une
fonction simplifiée de recherche existe. Cette fonction `getKindDoc()` a pour
but de construire la règle de filtrage adéquate en tenant compte de la
hiérarchie dans ce type d'attribut.

    [php]
    include_once("FDL/Class.Doc.php");
    include_once("FDL/Lib.Dir.php");
    
    $dbaccess=GetParam("FREEDOM_DB");
    $tdoc=getKindDoc($dbaccess,
        "USER",         // nom de la famille
        "us_type",      // attribut énuméré sur lequel s'applique le filtrage
        "chefserv"      // clef à rechercher
    );
     
    while (list($k, $v) = each($tdoc)) {
        print "$k)".$v["title"]."(".getv($v,"us_mail","nomail").")\n";
    }

Cet exemple permet de sélectionner la liste des chefs de service. Le chef de
service a pour clef 'chefserv'.

## Recherche dans un array <span class="flag from release">3.0.0</span> {#core-ref:5342d63e-edc8-44fb-bed9-2fb113742849}

Pour une famille avec un tableau contenant une liste de valeur, le
filtre Postgresql suivant permet de filtrer les documents dont une des valeurs
est égale à une valeur précise :

    [php]
    $s->addFilter("'%s' = any(%s)", $expectedValue, $attrId);

Ce filtre, utilisant la fonction [`ANY`][pgallany], fonctionne aussi pour les
attributs multiples présents dans des tableaux (2 niveaux de profondeur).

Si le tableau contient une liste de nombre, pour filtrer ceux qui ont une des
valeurs supérieurs à 10, le filtre suivant peut être utilisé.

    [php]
    $s->addFilter("10 < any(%s)", $attrId);

Attention : du fait de l'écriture, l'opérateur est inversé.

Si le tableau contient une liste de texte, pour filtrer les documents dont un
des éléments contient une expression, le filtre suivant peut être utilisé


    [php]
    $s->addFilter("'%s' ~*< any(%s)", $expectedText, $attrId);

Les opérateurs `~*<` et `~<` ne sont pas des opérateurs natifs de postgreSql.
Ils sont fournis par Dynacase pour gérer ce type de requêtes. Ce sont les
opérateurs "commutateur" des opérateurs natifs `~*` et `~` fournis par
postgreSql.

Le filtre suivant, effectué sur l'ensemble des valeurs du tableau, est moins
rapide que le filtre précédent. Il peut être utilisé 

    [php]
    $s->addFilter("%s::text ~* '%s'", $attrId, $expectedText);

Soit `my_v` l'attribut qui fait l'objet de la recherche. Le tableau suivant
illustre les différences entre ces deux filtres.

|             Filtre             | {"Hello world", "Goodbye others"} |
| ------------------------------ | --------------------------------- |
| `my_v::text ~ 'Hello'`         | True                              |
| `my_v::text ~ 'others'`        | True                              |
| `my_v::text ~ 'Hello.*others'` | True                              |
| `my_v::text ~ '"Hello"`        | True                              |
|                                |                                   |
| `'Hello' ~< any(my_v)`         | True                              |
| `'others' ~< any(my_v)`        | True                              |
| `'Hello.*others' ~< any(my_v)` | False                             |
| `'"Hello"' ~< any(my_v)`       | False                             |
|                                |                                   |



## Recherche avec jointure {#core-ref:82d4a6a8-39da-4ad1-a697-8da77c9aff07}

Il est possible d'ajouter des critères portant sur une autre table en utilisant
un mécanisme de jointure. Ce mécanisme ne permet pas de récupérer des données
provenant de cette autre table mais permet de les utiliser comme critère de
recherche.

Exemple : recherche des documents qui ont dans l'historique un ordre de
suppression émis par l'utilisateur courant

    [php]
    $s=new searchDoc();
    $s->trash='only'; // recherche dans les documents supprimés (mis dans la corbeille)
    $s->join("id = dochisto(id)");
    $s->addFilter("dochisto.uid = %d",$this->getSystemUserId());
    $s->addFilter("dochisto.code = 'DELETE'");
    $s->distinct=true;
    $result= $s->search();

Il est notamment possible d'utiliser, entre autres, les tables `dochisto`,
`docutag` ou `docrel` pour établir un critère de jointure.

*Attention* : On ne peut utiliser qu'un seul ordre "join" par requête.

Il est aussi possible de créer un critère sur une famille liée :

    [php]
    $s=new SearchDoc($dbaccess,"ZOO_ANIMAL");
    // la famille ZOO_ANIMAL est liée à la famille ZOO_ESPECE via l'attribut AN_ESPECE
    $s->join("an_espece::int = zoo_espece(initid)");
    $s->addFilter("zoo_espece.es_ordre='Rongeur'");
    $s->setObjectReturn(true);
    $s->search();
    while ($doc=$s->nextDoc()) {
       print $doc->getTitle()."\n";
    }

Dans l'exemple décrit on recherche les animaux dont l'ordre déclaré dans
l'espèce est 'Rongeur'. Attention à bien lier les deux famille à travers
l'identificateur initial (`initid`) dans le cas des relations créées avec les
options par défaut.

# Recherche de famille {#core-ref:1a33f90f-3d48-4eb8-8415-e49a1ad34e7e}

Pour rechercher des familles, il faut utiliser la valeur "-1" lors de la
construction de l'objet _recherche_.

    [php]
    $sd=new SearchDoc("", -1); 
    // toutes les familles 
    $sd->search();



<!-- link -->
[searchdoc]:        #core-ref:a5216d5c-4e0f-4e3c-9553-7cbfda6b3255
[propdoc]:          #core-ref:9aa8edfa-2f2a-11e2-aaec-838a12b40353 "Liste des propriétés du document"
[layoutblock]:      #core-ref:587b563e-7371-469f-9d1e-350607056c73
[formatcollection]: #core-ref:74ce9ce4-8e4e-42ee-a0df-415eb6897a81
[pgop]:             http://www.postgresql.org/docs/9.1/static/functions.html "Opérateurs Postgresql 9.1"
[docattributs]:     #core-ref:4e167170-33ed-11e2-8134-a7f43955d6f3
[attdocid]:         #core-ref:d461d5f5-b635-47a0-944d-473c227587ab
[phpiterator]:      http://php.net/manual/fr/class.iterator.php "Interface Iterator"
[docacl]:           #core-ref:a99dcc5f-f42f-4574-bbfa-d7bb0573c95d "Droits du document"
[pgallany]:         http://www.postgresql.org/docs/9.3/static/functions-comparisons.html#AEN18486 "Opérateurs ANY/ALL"
